<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNBLOCKED GAMES — GEOMETRY DASH</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --hacker-green: #00ff41;
      --hacker-green-dark: #00cc33;
      --hacker-green-bright: #00ff88;
      --hacker-bg: #000000;
      --text: #00ff41;
      --glitch-red: #ff0040;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: var(--hacker-bg);
      color: var(--text);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 1200px;
      background: rgba(0, 0, 0, 0.9);
      border: 3px solid var(--hacker-green);
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
      border-radius: 10px;
      overflow: hidden;
    }

    .game-header {
      padding: 15px 20px;
      background: rgba(0, 255, 65, 0.1);
      border-bottom: 2px solid var(--hacker-green);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .game-title {
      font-size: 1.2rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px var(--hacker-green);
    }

    .game-stats {
      display: flex;
      gap: 20px;
      font-size: 0.9rem;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .stat-label {
      opacity: 0.7;
    }

    .stat-value {
      font-weight: 600;
      color: var(--hacker-green-bright);
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 600px;
      background: #000000;
      cursor: pointer;
    }

    .game-ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .game-overlay {
      background: rgba(0, 0, 0, 0.9);
      padding: 40px;
      border: 3px solid var(--hacker-green);
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 50px rgba(0, 255, 65, 0.5);
      max-width: 500px;
      width: 90%;
    }

    .overlay-title {
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 20px var(--hacker-green);
    }

    .overlay-subtitle {
      font-size: 1rem;
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }

    .btn {
      display: inline-block;
      padding: 12px 30px;
      background: transparent;
      border: 2px solid var(--hacker-green);
      color: var(--hacker-green);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      pointer-events: auto;
      margin: 5px;
    }

    .btn:hover {
      background: var(--hacker-green);
      color: var(--hacker-bg);
      box-shadow: 0 0 20px var(--hacker-green);
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .hidden {
      display: none !important;
    }

    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      opacity: 0.6;
      text-align: center;
      pointer-events: none;
    }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: var(--hacker-green);
      text-decoration: none;
      font-size: 0.9rem;
      padding: 8px 16px;
      border: 1px solid var(--hacker-green);
      border-radius: 4px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: var(--hacker-green);
      color: var(--hacker-bg);
      box-shadow: 0 0 10px var(--hacker-green);
    }

    @media (max-width: 768px) {
      #gameCanvas {
        height: 400px;
      }

      .game-header {
        padding: 10px 15px;
      }

      .game-title {
        font-size: 1rem;
      }

      .game-stats {
        font-size: 0.8rem;
        gap: 10px;
      }

      .overlay-title {
        font-size: 1.5rem;
      }

      .overlay-subtitle {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">← BACK</a>
  
  <div class="game-container">
    <div class="game-header">
      <div class="game-title">GEOMETRY DASH</div>
      <div class="game-stats">
        <div class="stat">
          <span class="stat-label">LEVEL:</span>
          <span class="stat-value" id="levelDisplay">1</span>
        </div>
        <div class="stat">
          <span class="stat-label">SCORE:</span>
          <span class="stat-value" id="scoreDisplay">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">BEST:</span>
          <span class="stat-value" id="bestDisplay">0</span>
        </div>
      </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui">
      <div id="startScreen" class="game-overlay">
        <div class="overlay-title">GEOMETRY DASH</div>
        <div class="overlay-subtitle">
          Press SPACE or CLICK to jump<br>
          Avoid obstacles and spikes<br>
          Yellow pads give extra bounce!<br>
          Complete all 3 levels!
        </div>
        <button class="btn" onclick="startGame()">START GAME</button>
      </div>
      
      <div id="gameOverScreen" class="game-overlay hidden">
        <div class="overlay-title">GAME OVER</div>
        <div class="overlay-subtitle" id="gameOverText"></div>
        <button class="btn" onclick="restartLevel()">RETRY</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
      
      <div id="levelCompleteScreen" class="game-overlay hidden">
        <div class="overlay-title">LEVEL COMPLETE!</div>
        <div class="overlay-subtitle" id="levelCompleteText"></div>
        <button class="btn" onclick="nextLevel()">NEXT LEVEL</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
      
      <div id="allCompleteScreen" class="game-overlay hidden">
        <div class="overlay-title">ALL LEVELS COMPLETE!</div>
        <div class="overlay-subtitle">Congratulations! You've mastered Geometry Dash!</div>
        <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
    </div>
    
    <div class="controls-hint">SPACE or CLICK to JUMP</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = 600;
      if (window.innerWidth <= 768) {
        canvas.height = 400;
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Game state
    let gameState = 'menu';
    let currentLevel = 1;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('geometryDashBest') || '0');
    let gameSpeed = 4.7; // Geometry Dash speed
    
    // Player cube - Geometry Dash style
    const player = {
      x: 80,
      y: 0,
      size: 30,
      velocityY: 0,
      gravity: 0.94, // Geometry Dash gravity
      jumpPower: -12.5, // Geometry Dash jump power
      rotation: 0,
      rotationSpeed: 5,
      onGround: false,
      wasOnGround: false,
      color: '#00ff41'
    };
    
    // Ground
    const ground = {
      y: 0,
      height: 50
    };
    
    // Game objects
    let blocks = []; // Normal blocks
    let jumpPads = []; // Yellow jump pads
    let groundSpikes = []; // Spikes on ground
    let ceilingSpikes = []; // Spikes on ceiling
    
    // Level definitions - Geometry Dash style
    const levels = [
      // Level 1 - Stereo Madness style
      {
        blocks: [
          { x: 400, width: 40, height: 120 },
          { x: 600, width: 40, height: 100 },
          { x: 800, width: 40, height: 140 },
          { x: 1000, width: 40, height: 110 },
          { x: 1200, width: 40, height: 130 },
          { x: 1400, width: 40, height: 100 }
        ],
        jumpPads: [
          { x: 500 },
          { x: 700 },
          { x: 900 },
          { x: 1100 }
        ],
        groundSpikes: [
          { x: 450, width: 30 },
          { x: 650, width: 30 },
          { x: 850, width: 30 },
          { x: 1050, width: 30 }
        ],
        ceilingSpikes: [],
        length: 1800
      },
      // Level 2 - Back on Track style
      {
        blocks: [
          { x: 350, width: 40, height: 100 },
          { x: 500, width: 40, height: 150 },
          { x: 650, width: 40, height: 90 },
          { x: 800, width: 40, height: 130 },
          { x: 950, width: 40, height: 110 },
          { x: 1100, width: 40, height: 140 },
          { x: 1250, width: 40, height: 100 },
          { x: 1400, width: 40, height: 120 }
        ],
        jumpPads: [
          { x: 425 },
          { x: 575 },
          { x: 725 },
          { x: 875 },
          { x: 1025 },
          { x: 1175 }
        ],
        groundSpikes: [
          { x: 475, width: 30 },
          { x: 625, width: 30 },
          { x: 775, width: 30 },
          { x: 925, width: 30 },
          { x: 1075, width: 30 }
        ],
        ceilingSpikes: [
          { x: 550, width: 30 },
          { x: 800, width: 30 }
        ],
        length: 2000
      },
      // Level 3 - Polargeist style (harder)
      {
        blocks: [
          { x: 300, width: 40, height: 100 },
          { x: 450, width: 40, height: 160 },
          { x: 600, width: 40, height: 80 },
          { x: 750, width: 40, height: 150 },
          { x: 900, width: 40, height: 110 },
          { x: 1050, width: 40, height: 140 },
          { x: 1200, width: 40, height: 100 },
          { x: 1350, width: 40, height: 130 },
          { x: 1500, width: 40, height: 120 },
          { x: 1650, width: 40, height: 110 }
        ],
        jumpPads: [
          { x: 375 },
          { x: 525 },
          { x: 675 },
          { x: 825 },
          { x: 975 },
          { x: 1125 },
          { x: 1275 },
          { x: 1425 }
        ],
        groundSpikes: [
          { x: 400, width: 30 },
          { x: 550, width: 30 },
          { x: 700, width: 30 },
          { x: 850, width: 30 },
          { x: 1000, width: 30 },
          { x: 1150, width: 30 },
          { x: 1300, width: 30 }
        ],
        ceilingSpikes: [
          { x: 500, width: 30 },
          { x: 750, width: 30 },
          { x: 1000, width: 30 },
          { x: 1250, width: 30 },
          { x: 1500, width: 30 }
        ],
        length: 2200
      }
    ];
    
    let cameraX = 0;
    let levelProgress = 0;
    
    // Initialize ground
    function initGround() {
      ground.y = canvas.height - ground.height;
    }
    
    // Initialize player
    function initPlayer() {
      player.y = ground.y - player.size;
      player.velocityY = 0;
      player.rotation = 0;
      player.onGround = true;
      player.wasOnGround = true;
    }
    
    // Load level
    function loadLevel(levelNum) {
      const level = levels[levelNum - 1];
      blocks = level.blocks.map(b => ({ ...b }));
      jumpPads = level.jumpPads.map(j => ({ ...j }));
      groundSpikes = level.groundSpikes.map(s => ({ ...s }));
      ceilingSpikes = level.ceilingSpikes.map(s => ({ ...s }));
      cameraX = 0;
      levelProgress = 0;
      initPlayer();
      gameSpeed = 4.7 + (levelNum - 1) * 0.5;
    }
    
    // Jump
    function jump() {
      if (player.onGround && gameState === 'playing') {
        player.velocityY = player.jumpPower;
        player.onGround = false;
        player.rotationSpeed = 5;
      }
    }
    
    // Update player
    function updatePlayer() {
      if (gameState !== 'playing') return;
      
      player.wasOnGround = player.onGround;
      
      // Apply gravity
      player.velocityY += player.gravity;
      player.y += player.velocityY;
      
      // Rotate cube
      if (!player.onGround) {
        player.rotation += player.rotationSpeed;
        if (player.rotation >= 360) player.rotation -= 360;
      }
      
      // Ground collision
      if (player.y + player.size >= ground.y) {
        player.y = ground.y - player.size;
        player.velocityY = 0;
        player.onGround = true;
        player.rotation = Math.round(player.rotation / 90) * 90; // Snap to 90 degree increments on ground
      } else {
        player.onGround = false;
      }
      
      // Ceiling collision
      if (player.y < 0) {
        player.y = 0;
        player.velocityY = 0;
      }
      
      // Check jump pad collision
      for (let pad of jumpPads) {
        const padX = pad.x - cameraX;
        const padY = ground.y - 20;
        const padSize = 40;
        
        if (player.x + player.size > padX && player.x < padX + padSize &&
            player.y + player.size > padY && player.y < padY + padSize &&
            player.onGround && !player.wasOnGround) {
          player.velocityY = -18; // Extra bounce from jump pad
          player.onGround = false;
          break;
        }
      }
    }
    
    // Update camera and world
    function updateWorld() {
      if (gameState !== 'playing') return;
      
      cameraX += gameSpeed;
      levelProgress = cameraX;
      
      // Check level complete
      const currentLevelData = levels[currentLevel - 1];
      if (levelProgress >= currentLevelData.length) {
        completeLevel();
      }
    }
    
    // Check collisions
    function checkCollisions() {
      if (gameState !== 'playing') return;
      
      const playerLeft = player.x;
      const playerRight = player.x + player.size;
      const playerTop = player.y;
      const playerBottom = player.y + player.size;
      
      // Check block collisions
      for (let block of blocks) {
        const blockLeft = block.x - cameraX;
        const blockRight = block.x - cameraX + block.width;
        const blockTop = ground.y - block.height;
        const blockBottom = ground.y;
        
        if (playerRight > blockLeft && playerLeft < blockRight &&
            playerBottom > blockTop && playerTop < blockBottom) {
          gameOver();
          return;
        }
      }
      
      // Check ground spike collisions
      for (let spike of groundSpikes) {
        const spikeX = spike.x - cameraX;
        const spikeWidth = spike.width;
        const spikeY = ground.y - 30;
        
        // Triangle collision check
        const spikeCenterX = spikeX + spikeWidth / 2;
        const distX = Math.abs((player.x + player.size / 2) - spikeCenterX);
        const distY = (player.y + player.size) - spikeY;
        
        if (distX < spikeWidth / 2 + player.size / 2 && 
            distY < 30 && distY > 0 &&
            (player.y + player.size) > spikeY) {
          gameOver();
          return;
        }
      }
      
      // Check ceiling spike collisions
      for (let spike of ceilingSpikes) {
        const spikeX = spike.x - cameraX;
        const spikeWidth = spike.width;
        const spikeY = 30;
        
        const spikeCenterX = spikeX + spikeWidth / 2;
        const distX = Math.abs((player.x + player.size / 2) - spikeCenterX);
        const distY = spikeY - player.y;
        
        if (distX < spikeWidth / 2 + player.size / 2 && 
            distY < 30 && distY > 0 &&
            player.y < spikeY + 30) {
          gameOver();
          return;
        }
      }
    }
    
    // Update score
    function updateScore() {
      if (gameState === 'playing') {
        score = Math.floor(levelProgress / 10) + (currentLevel - 1) * 2000;
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('geometryDashBest', bestScore.toString());
        }
        updateUI();
      }
    }
    
    // Update UI
    function updateUI() {
      document.getElementById('levelDisplay').textContent = currentLevel;
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('bestDisplay').textContent = bestScore;
    }
    
    // Draw functions
    function drawBackground() {
      // Dark background with gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#0a0a1a');
      gradient.addColorStop(0.5, '#050510');
      gradient.addColorStop(1, '#000000');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Subtle grid
      ctx.strokeStyle = 'rgba(0, 255, 65, 0.05)';
      ctx.lineWidth = 1;
      for (let i = 0; i < canvas.width; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i - (cameraX % 50), 0);
        ctx.lineTo(i - (cameraX % 50), canvas.height);
        ctx.stroke();
      }
    }
    
    function drawGround() {
      // Ground base
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, ground.y, canvas.width, ground.height);
      
      // Ground top line
      ctx.strokeStyle = '#00ff41';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, ground.y);
      ctx.lineTo(canvas.width, ground.y);
      ctx.stroke();
      
      // Ground glow
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#00ff41';
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    function drawPlayer() {
      ctx.save();
      
      // Rotate around center
      const centerX = player.x + player.size / 2;
      const centerY = player.y + player.size / 2;
      ctx.translate(centerX, centerY);
      ctx.rotate((player.rotation * Math.PI) / 180);
      
      // Draw cube with glow
      ctx.shadowBlur = 20;
      ctx.shadowColor = player.color;
      ctx.fillStyle = player.color;
      ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
      ctx.shadowBlur = 0;
      
      // Cube outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(-player.size / 2, -player.size / 2, player.size, player.size);
      
      // Cube face (always visible)
      ctx.fillStyle = '#000000';
      const eyeSize = 4;
      const eyeY = -player.size / 2 + 8;
      ctx.fillRect(-player.size / 2 + 6, eyeY, eyeSize, eyeSize);
      ctx.fillRect(-player.size / 2 + player.size - 10, eyeY, eyeSize, eyeSize);
      
      // Mouth
      ctx.fillRect(-player.size / 2 + 8, -player.size / 2 + player.size - 12, player.size - 16, 3);
      
      ctx.restore();
    }
    
    function drawBlocks() {
      for (let block of blocks) {
        const x = block.x - cameraX;
        if (x > -block.width && x < canvas.width) {
          // Block shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + 2, ground.y - block.height + 2, block.width, block.height);
          
          // Block main
          ctx.fillStyle = '#ff0040';
          ctx.fillRect(x, ground.y - block.height, block.width, block.height);
          
          // Block outline
          ctx.strokeStyle = '#cc0033';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, ground.y - block.height, block.width, block.height);
          
          // Block glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff0040';
          ctx.fillRect(x, ground.y - block.height, block.width, 3);
          ctx.shadowBlur = 0;
        }
      }
    }
    
    function drawJumpPads() {
      for (let pad of jumpPads) {
        const x = pad.x - cameraX;
        const y = ground.y - 20;
        const size = 40;
        
        if (x > -size && x < canvas.width) {
          // Jump pad glow
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffff00';
          
          // Yellow jump pad
          ctx.fillStyle = '#ffff00';
          ctx.fillRect(x, y, size, 20);
          
          // Jump pad outline
          ctx.strokeStyle = '#ffaa00';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, size, 20);
          
          // Jump pad arrows
          ctx.fillStyle = '#000000';
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(x + 8 + i * 12, y + 15);
            ctx.lineTo(x + 12 + i * 12, y + 10);
            ctx.lineTo(x + 16 + i * 12, y + 15);
            ctx.closePath();
            ctx.fill();
          }
          
          ctx.shadowBlur = 0;
        }
      }
    }
    
    function drawSpikes(spikes, isCeiling) {
      ctx.fillStyle = '#ff0040';
      for (let spike of spikes) {
        const x = spike.x - cameraX;
        const width = spike.width;
        const height = 30;
        
        if (x > -width && x < canvas.width) {
          const y = isCeiling ? 0 : ground.y - height;
          
          ctx.beginPath();
          if (isCeiling) {
            ctx.moveTo(x, y);
            ctx.lineTo(x + width / 2, y + height);
            ctx.lineTo(x + width, y);
          } else {
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
          }
          ctx.closePath();
          
          // Spike glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff0040';
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Spike outline
          ctx.strokeStyle = '#cc0033';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }
    
    function drawProgress() {
      if (gameState === 'playing') {
        const currentLevelData = levels[currentLevel - 1];
        const progress = Math.min(levelProgress / currentLevelData.length, 1);
        
        // Progress bar background
        ctx.fillStyle = 'rgba(0, 255, 65, 0.2)';
        ctx.fillRect(0, canvas.height - 8, canvas.width, 8);
        
        // Progress bar
        ctx.fillStyle = '#00ff41';
        ctx.fillRect(0, canvas.height - 8, canvas.width * progress, 8);
        
        // Progress indicator
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(canvas.width * progress - 3, canvas.height - 12, 6, 12);
      }
    }
    
    // Game state functions
    function startGame() {
      currentLevel = 1;
      score = 0;
      loadLevel(currentLevel);
      gameState = 'playing';
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('levelCompleteScreen').classList.add('hidden');
      document.getElementById('allCompleteScreen').classList.add('hidden');
      updateUI();
    }
    
    function restartGame() {
      currentLevel = 1;
      score = 0;
      startGame();
    }
    
    function showStartScreen() {
      gameState = 'menu';
      document.getElementById('startScreen').classList.remove('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('levelCompleteScreen').classList.add('hidden');
      document.getElementById('allCompleteScreen').classList.add('hidden');
      updateUI();
    }
    
    function gameOver() {
      gameState = 'gameOver';
      document.getElementById('gameOverText').textContent = 
        `Score: ${score} | Level: ${currentLevel}`;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }
    
    function restartLevel() {
      loadLevel(currentLevel);
      gameState = 'playing';
      document.getElementById('gameOverScreen').classList.add('hidden');
      updateUI();
    }
    
    function completeLevel() {
      gameState = 'levelComplete';
      if (currentLevel < 3) {
        document.getElementById('levelCompleteText').textContent = 
          `Level ${currentLevel} Complete! Ready for Level ${currentLevel + 1}?`;
        document.getElementById('levelCompleteScreen').classList.remove('hidden');
      } else {
        gameState = 'allComplete';
        document.getElementById('allCompleteScreen').classList.remove('hidden');
      }
    }
    
    function nextLevel() {
      currentLevel++;
      loadLevel(currentLevel);
      gameState = 'playing';
      document.getElementById('levelCompleteScreen').classList.add('hidden');
      updateUI();
    }
    
    // Event listeners
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    });
    
    canvas.addEventListener('click', jump);
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    });
    
    // Game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawBackground();
      
      if (gameState === 'playing') {
        updatePlayer();
        updateWorld();
        checkCollisions();
        updateScore();
      }
      
      drawGround();
      drawBlocks();
      drawJumpPads();
      drawSpikes(groundSpikes, false);
      drawSpikes(ceilingSpikes, true);
      drawPlayer();
      drawProgress();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Initialize
    initGround();
    initPlayer();
    updateUI();
    gameLoop();
  </script>
</body>
</html>
