<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNBLOCKED GAMES — GEOMETRY DASH</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000000;
      color: #00ff41;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 1200px;
      background: #000000;
      border: 3px solid #00ff41;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
      border-radius: 10px;
      overflow: hidden;
    }

    .game-header {
      padding: 15px 20px;
      background: rgba(0, 255, 65, 0.1);
      border-bottom: 2px solid #00ff41;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .game-title {
      font-size: 1.2rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .game-stats {
      display: flex;
      gap: 20px;
      font-size: 0.9rem;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 600px;
      background: #000000;
      cursor: pointer;
    }

    .game-ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .game-overlay {
      background: rgba(0, 0, 0, 0.95);
      padding: 40px;
      border: 3px solid #00ff41;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 50px rgba(0, 255, 65, 0.5);
      max-width: 500px;
      width: 90%;
    }

    .overlay-title {
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 20px;
      text-transform: uppercase;
    }

    .overlay-subtitle {
      font-size: 1rem;
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }

    .btn {
      display: inline-block;
      padding: 12px 30px;
      background: transparent;
      border: 2px solid #00ff41;
      color: #00ff41;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      cursor: pointer;
      pointer-events: auto;
      margin: 5px;
    }

    .btn:hover {
      background: #00ff41;
      color: #000000;
    }

    .hidden {
      display: none !important;
    }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #00ff41;
      text-decoration: none;
      font-size: 0.9rem;
      padding: 8px 16px;
      border: 1px solid #00ff41;
      border-radius: 4px;
    }

    .back-link:hover {
      background: #00ff41;
      color: #000000;
    }

    @media (max-width: 768px) {
      #gameCanvas {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">← BACK</a>
  
  <div class="game-container">
    <div class="game-header">
      <div class="game-title">GEOMETRY DASH — STEREO MADNESS</div>
      <div class="game-stats">
        <span>SCORE: <span id="scoreDisplay">0</span></span>
        <span>BEST: <span id="bestDisplay">0</span></span>
      </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui">
      <div id="startScreen" class="game-overlay">
        <div class="overlay-title">STEREO MADNESS</div>
        <div class="overlay-subtitle">
          Press SPACE or CLICK to jump<br>
          Complete the level!
        </div>
        <button class="btn" onclick="startGame()">START</button>
      </div>
      
      <div id="gameOverScreen" class="game-overlay hidden">
        <div class="overlay-title">GAME OVER</div>
        <div class="overlay-subtitle" id="gameOverText"></div>
        <button class="btn" onclick="restartGame()">RETRY</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
      
      <div id="completeScreen" class="game-overlay hidden">
        <div class="overlay-title">LEVEL COMPLETE!</div>
        <div class="overlay-subtitle">Congratulations!</div>
        <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      'use strict';
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Constants
      const GRAVITY = 0.94;
      const JUMP_POWER = -12.5;
      const GAME_SPEED = 4.7;
      const PLAYER_SIZE = 30;
      const GROUND_HEIGHT = 50;
      const LEVEL_LENGTH = 4000;
      
      // Game state
      let gameState = 'menu';
      let score = 0;
      let bestScore = parseInt(localStorage.getItem('gdBest') || '0');
      let cameraX = 0;
      let levelProgress = 0;
      
      // Initialize canvas
      function initCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = 600;
        if (window.innerWidth <= 768) {
          canvas.height = 400;
        }
      }
      
      initCanvas();
      window.addEventListener('resize', initCanvas);
      
      // Get ground Y position
      function getGroundY() {
        return canvas.height - GROUND_HEIGHT;
      }
      
      // Get player start position
      function getPlayerStartY() {
        return getGroundY() - PLAYER_SIZE;
      }
      
      // Player
      const player = {
        x: 100,
        y: getPlayerStartY(),
        size: PLAYER_SIZE,
        velocityY: 0,
        rotation: 0,
        rotationSpeed: 5,
        onGround: true
      };
      
      // Level data - Stereo Madness
      const blocks = [
        { x: 450, width: 40, height: 120 },
        { x: 620, width: 40, height: 100 },
        { x: 790, width: 40, height: 140 },
        { x: 960, width: 40, height: 110 },
        { x: 1130, width: 40, height: 130 },
        { x: 1300, width: 40, height: 100 },
        { x: 1470, width: 40, height: 150 },
        { x: 1640, width: 40, height: 90 },
        { x: 1810, width: 40, height: 120 },
        { x: 1980, width: 40, height: 110 },
        { x: 2150, width: 40, height: 140 },
        { x: 2320, width: 40, height: 100 },
        { x: 2490, width: 40, height: 130 },
        { x: 2660, width: 40, height: 110 },
        { x: 2830, width: 40, height: 120 },
        { x: 3000, width: 40, height: 100 },
        { x: 3170, width: 40, height: 140 },
        { x: 3340, width: 40, height: 90 },
        { x: 3510, width: 40, height: 130 },
        { x: 3680, width: 40, height: 110 }
      ];
      
      const jumpPads = [
        { x: 500 }, { x: 670 }, { x: 840 }, { x: 1010 }, { x: 1180 },
        { x: 1350 }, { x: 1520 }, { x: 1690 }, { x: 1860 }, { x: 2030 },
        { x: 2200 }, { x: 2370 }, { x: 2540 }, { x: 2710 }, { x: 2880 },
        { x: 3050 }, { x: 3220 }, { x: 3390 }, { x: 3560 }, { x: 3730 }
      ];
      
      const groundSpikes = [
        { x: 480 }, { x: 650 }, { x: 820 }, { x: 990 }, { x: 1160 },
        { x: 1330 }, { x: 1500 }, { x: 1670 }, { x: 1840 }, { x: 2010 },
        { x: 2180 }, { x: 2350 }, { x: 2520 }, { x: 2690 }, { x: 2860 },
        { x: 3030 }, { x: 3200 }, { x: 3370 }, { x: 3540 }, { x: 3710 }
      ];
      
      // Initialize player
      function initPlayer() {
        player.x = 100;
        player.y = getPlayerStartY();
        player.velocityY = 0;
        player.rotation = 0;
        player.onGround = true;
      }
      
      // Reset game
      function resetGame() {
        cameraX = 0;
        levelProgress = 0;
        score = 0;
        initPlayer();
      }
      
      // Jump
      function jump() {
        if (gameState === 'playing' && player.onGround) {
          player.velocityY = JUMP_POWER;
          player.onGround = false;
        }
      }
      
      // Update player
      function updatePlayer() {
        if (gameState !== 'playing') return;
        
        const groundY = getGroundY();
        
        // Apply gravity
        player.velocityY += GRAVITY;
        player.y += player.velocityY;
        
        // Rotate cube when in air
        if (!player.onGround) {
          player.rotation += player.rotationSpeed;
          if (player.rotation >= 360) player.rotation -= 360;
        } else {
          // Snap to 90 degree increments on ground
          player.rotation = Math.round(player.rotation / 90) * 90;
        }
        
        // Ground collision
        if (player.y + player.size >= groundY) {
          player.y = groundY - player.size;
          player.velocityY = 0;
          player.onGround = true;
        }
        
        // Ceiling collision
        if (player.y < 0) {
          player.y = 0;
          player.velocityY = 0;
        }
        
        // Jump pad collision
        const playerCenterX = player.x + player.size / 2;
        const playerBottom = player.y + player.size;
        
        for (let pad of jumpPads) {
          const padX = pad.x - cameraX;
          const padY = groundY - 20;
          
          if (playerCenterX > padX && playerCenterX < padX + 40 &&
              playerBottom >= padY && playerBottom <= padY + 20 &&
              player.onGround && player.velocityY >= 0) {
            player.velocityY = -18;
            player.onGround = false;
            break;
          }
        }
      }
      
      // Update camera
      function updateCamera() {
        if (gameState !== 'playing') return;
        
        // Move camera forward with game speed
        cameraX += GAME_SPEED;
        levelProgress = cameraX;
        
        // Check level complete
        if (levelProgress >= LEVEL_LENGTH) {
          completeLevel();
        }
      }
      
      // Check collisions
      function checkCollisions() {
        if (gameState !== 'playing') return;
        
        const groundY = getGroundY();
        const playerLeft = player.x;
        const playerRight = player.x + player.size;
        const playerTop = player.y;
        const playerBottom = player.y + player.size;
        
        // Block collisions
        for (let block of blocks) {
          const blockX = block.x - cameraX;
          const blockY = groundY - block.height;
          
          if (playerRight > blockX && playerLeft < blockX + block.width &&
              playerBottom > blockY && playerTop < blockY + block.height) {
            gameOver();
            return;
          }
        }
        
        // Spike collisions
        for (let spike of groundSpikes) {
          const spikeX = spike.x - cameraX;
          const spikeY = groundY - 30;
          const spikeCenterX = spikeX + 15;
          const playerCenterX = player.x + player.size / 2;
          const distX = Math.abs(playerCenterX - spikeCenterX);
          const distY = playerBottom - spikeY;
          
          if (distX < 20 && distY > 0 && distY < 30 && playerBottom > spikeY) {
            gameOver();
            return;
          }
        }
      }
      
      // Update score
      function updateScore() {
        if (gameState === 'playing') {
          score = Math.floor(levelProgress / 10);
          if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('gdBest', bestScore.toString());
          }
          document.getElementById('scoreDisplay').textContent = score;
          document.getElementById('bestDisplay').textContent = bestScore;
        }
      }
      
      // Drawing functions
      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#0a0a1a');
        gradient.addColorStop(1, '#000000');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      function drawGround() {
        const groundY = getGroundY();
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);
        ctx.strokeStyle = '#00ff41';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(canvas.width, groundY);
        ctx.stroke();
      }
      
      function drawPlayer() {
        const groundY = getGroundY();
        ctx.save();
        const centerX = player.x - cameraX + player.size / 2;
        const centerY = player.y + player.size / 2;
        ctx.translate(centerX, centerY);
        ctx.rotate((player.rotation * Math.PI) / 180);
        
        ctx.fillStyle = '#00ff41';
        ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(-player.size / 2, -player.size / 2, player.size, player.size);
        
        ctx.fillStyle = '#000000';
        ctx.fillRect(-player.size / 2 + 6, -player.size / 2 + 8, 4, 4);
        ctx.fillRect(-player.size / 2 + player.size - 10, -player.size / 2 + 8, 4, 4);
        ctx.fillRect(-player.size / 2 + 8, -player.size / 2 + player.size - 12, player.size - 16, 3);
        
        ctx.restore();
      }
      
      function drawBlocks() {
        const groundY = getGroundY();
        ctx.fillStyle = '#ff0040';
        for (let block of blocks) {
          const x = block.x - cameraX;
          if (x > -block.width && x < canvas.width) {
            ctx.fillRect(x, groundY - block.height, block.width, block.height);
            ctx.strokeStyle = '#cc0033';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, groundY - block.height, block.width, block.height);
          }
        }
      }
      
      function drawJumpPads() {
        const groundY = getGroundY();
        for (let pad of jumpPads) {
          const x = pad.x - cameraX;
          if (x > -40 && x < canvas.width) {
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(x, groundY - 20, 40, 20);
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, groundY - 20, 40, 20);
            
            // Draw arrows
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(x + 8 + i * 12, groundY - 5);
              ctx.lineTo(x + 12 + i * 12, groundY - 10);
              ctx.lineTo(x + 16 + i * 12, groundY - 5);
              ctx.closePath();
              ctx.fill();
            }
          }
        }
      }
      
      function drawSpikes() {
        const groundY = getGroundY();
        ctx.fillStyle = '#ff0040';
        for (let spike of groundSpikes) {
          const x = spike.x - cameraX;
          if (x > -30 && x < canvas.width) {
            ctx.beginPath();
            ctx.moveTo(x, groundY);
            ctx.lineTo(x + 15, groundY - 30);
            ctx.lineTo(x + 30, groundY);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
      
      function drawProgress() {
        if (gameState === 'playing') {
          const progress = Math.min(levelProgress / LEVEL_LENGTH, 1);
          ctx.fillStyle = 'rgba(0, 255, 65, 0.2)';
          ctx.fillRect(0, canvas.height - 8, canvas.width, 8);
          ctx.fillStyle = '#00ff41';
          ctx.fillRect(0, canvas.height - 8, canvas.width * progress, 8);
        }
      }
      
      // Game state functions
      window.startGame = function() {
        resetGame();
        gameState = 'playing';
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('completeScreen').classList.add('hidden');
        updateScore();
      };
      
      window.restartGame = function() {
        resetGame();
        gameState = 'playing';
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('completeScreen').classList.add('hidden');
        updateScore();
      };
      
      window.showStartScreen = function() {
        gameState = 'menu';
        document.getElementById('startScreen').classList.remove('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('completeScreen').classList.add('hidden');
      };
      
      function gameOver() {
        gameState = 'gameOver';
        document.getElementById('gameOverText').textContent = 'Score: ' + score;
        document.getElementById('gameOverScreen').classList.remove('hidden');
      }
      
      function completeLevel() {
        gameState = 'complete';
        document.getElementById('completeScreen').classList.remove('hidden');
      }
      
      // Event listeners
      document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
          e.preventDefault();
          jump();
        }
      });
      
      canvas.addEventListener('click', jump);
      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        jump();
      });
      
      // Game loop
      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawBackground();
        
        if (gameState === 'playing') {
          updatePlayer();
          updateCamera();
          checkCollisions();
          updateScore();
        }
        
        drawGround();
        drawBlocks();
        drawJumpPads();
        drawSpikes();
        drawPlayer();
        drawProgress();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Initialize
      initPlayer();
      updateScore();
      gameLoop();
    })();
  </script>
</body>
</html>
