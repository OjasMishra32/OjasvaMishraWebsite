<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UNBLOCKED GAMES — GEOMETRY DASH</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: #000000;
      color: #00ff41;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 1200px;
      background: #000000;
      border: 3px solid #00ff41;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
      border-radius: 10px;
      overflow: hidden;
    }

    .game-header {
      padding: 15px 20px;
      background: rgba(0, 255, 65, 0.1);
      border-bottom: 2px solid #00ff41;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .game-title {
      font-size: 1.2rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px #00ff41;
    }

    .game-stats {
      display: flex;
      gap: 20px;
      font-size: 0.9rem;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .stat-label {
      opacity: 0.7;
    }

    .stat-value {
      font-weight: 600;
      color: #00ff88;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 600px;
      background: #000000;
      cursor: pointer;
    }

    .game-ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .game-overlay {
      background: rgba(0, 0, 0, 0.95);
      padding: 40px;
      border: 3px solid #00ff41;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 50px rgba(0, 255, 65, 0.5);
      max-width: 500px;
      width: 90%;
    }

    .overlay-title {
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 3px;
      text-shadow: 0 0 20px #00ff41;
    }

    .overlay-subtitle {
      font-size: 1rem;
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }

    .btn {
      display: inline-block;
      padding: 12px 30px;
      background: transparent;
      border: 2px solid #00ff41;
      color: #00ff41;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      pointer-events: auto;
      margin: 5px;
    }

    .btn:hover {
      background: #00ff41;
      color: #000000;
      box-shadow: 0 0 20px #00ff41;
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .hidden {
      display: none !important;
    }

    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      opacity: 0.6;
      text-align: center;
      pointer-events: none;
    }

    .back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #00ff41;
      text-decoration: none;
      font-size: 0.9rem;
      padding: 8px 16px;
      border: 1px solid #00ff41;
      border-radius: 4px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: #00ff41;
      color: #000000;
      box-shadow: 0 0 10px #00ff41;
    }

    @media (max-width: 768px) {
      #gameCanvas {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <a href="index.html" class="back-link">← BACK</a>
  
  <div class="game-container">
    <div class="game-header">
      <div class="game-title">GEOMETRY DASH — STEREO MADNESS</div>
      <div class="game-stats">
        <div class="stat">
          <span class="stat-label">SCORE:</span>
          <span class="stat-value" id="scoreDisplay">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">BEST:</span>
          <span class="stat-value" id="bestDisplay">0</span>
        </div>
      </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="game-ui">
      <div id="startScreen" class="game-overlay">
        <div class="overlay-title">STEREO MADNESS</div>
        <div class="overlay-subtitle">
          Press SPACE or CLICK to jump<br>
          Complete the level to win!
        </div>
        <button class="btn" onclick="startGame()">START</button>
      </div>
      
      <div id="gameOverScreen" class="game-overlay hidden">
        <div class="overlay-title">GAME OVER</div>
        <div class="overlay-subtitle" id="gameOverText"></div>
        <button class="btn" onclick="restartGame()">RETRY</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
      
      <div id="completeScreen" class="game-overlay hidden">
        <div class="overlay-title">LEVEL COMPLETE!</div>
        <div class="overlay-subtitle">Congratulations! You completed Stereo Madness!</div>
        <button class="btn" onclick="restartGame()">PLAY AGAIN</button>
        <button class="btn" onclick="showStartScreen()">MENU</button>
      </div>
    </div>
    
    <div class="controls-hint">SPACE or CLICK to JUMP</div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = 600;
      if (window.innerWidth <= 768) {
        canvas.height = 400;
      }
      updateConstants();
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Game constants
    const GRAVITY = 0.94;
    const JUMP_POWER = -12.5;
    const GAME_SPEED = 4.7;
    const PLAYER_SIZE = 30;
    const GROUND_HEIGHT = 50;
    
    // Calculated constants
    let GROUND_Y = 0;
    let PLAYER_START_X = 0;
    let PLAYER_START_Y = 0;
    
    function updateConstants() {
      GROUND_Y = canvas.height - GROUND_HEIGHT;
      PLAYER_START_X = 100;
      PLAYER_START_Y = GROUND_Y - PLAYER_SIZE;
    }
    updateConstants();
    
    // Game state
    let gameState = 'menu'; // menu, playing, gameOver, complete
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('gdBest') || '0');
    
    // Player
    const player = {
      x: PLAYER_START_X,
      y: PLAYER_START_Y,
      size: PLAYER_SIZE,
      velocityY: 0,
      rotation: 0,
      rotationSpeed: 5,
      onGround: true,
      color: '#00ff41'
    };
    
    // Camera
    let cameraX = 0;
    let levelProgress = 0;
    const LEVEL_LENGTH = 4000; // Stereo Madness approximate length
    
    // Level data - Stereo Madness layout
    const blocks = [
      { x: 450, width: 40, height: 120 },
      { x: 620, width: 40, height: 100 },
      { x: 790, width: 40, height: 140 },
      { x: 960, width: 40, height: 110 },
      { x: 1130, width: 40, height: 130 },
      { x: 1300, width: 40, height: 100 },
      { x: 1470, width: 40, height: 150 },
      { x: 1640, width: 40, height: 90 },
      { x: 1810, width: 40, height: 120 },
      { x: 1980, width: 40, height: 110 },
      { x: 2150, width: 40, height: 140 },
      { x: 2320, width: 40, height: 100 },
      { x: 2490, width: 40, height: 130 },
      { x: 2660, width: 40, height: 110 },
      { x: 2830, width: 40, height: 120 },
      { x: 3000, width: 40, height: 100 },
      { x: 3170, width: 40, height: 140 },
      { x: 3340, width: 40, height: 90 },
      { x: 3510, width: 40, height: 130 },
      { x: 3680, width: 40, height: 110 }
    ];
    
    const jumpPads = [
      { x: 500 },
      { x: 670 },
      { x: 840 },
      { x: 1010 },
      { x: 1180 },
      { x: 1350 },
      { x: 1520 },
      { x: 1690 },
      { x: 1860 },
      { x: 2030 },
      { x: 2200 },
      { x: 2370 },
      { x: 2540 },
      { x: 2710 },
      { x: 2880 },
      { x: 3050 },
      { x: 3220 },
      { x: 3390 },
      { x: 3560 },
      { x: 3730 }
    ];
    
    const groundSpikes = [
      { x: 480, width: 30 },
      { x: 650, width: 30 },
      { x: 820, width: 30 },
      { x: 990, width: 30 },
      { x: 1160, width: 30 },
      { x: 1330, width: 30 },
      { x: 1500, width: 30 },
      { x: 1670, width: 30 },
      { x: 1840, width: 30 },
      { x: 2010, width: 30 },
      { x: 2180, width: 30 },
      { x: 2350, width: 30 },
      { x: 2520, width: 30 },
      { x: 2690, width: 30 },
      { x: 2860, width: 30 },
      { x: 3030, width: 30 },
      { x: 3200, width: 30 },
      { x: 3370, width: 30 },
      { x: 3540, width: 30 },
      { x: 3710, width: 30 }
    ];
    
    // Initialize player
    function initPlayer() {
      player.x = PLAYER_START_X;
      player.y = PLAYER_START_Y;
      player.velocityY = 0;
      player.rotation = 0;
      player.onGround = true;
    }
    
    // Reset game
    function resetGame() {
      cameraX = 0;
      levelProgress = 0;
      score = 0;
      initPlayer();
    }
    
    // Jump function
    function jump() {
      if (gameState === 'playing' && player.onGround) {
        player.velocityY = JUMP_POWER;
        player.onGround = false;
      }
    }
    
    // Update player
    function updatePlayer() {
      if (gameState !== 'playing') return;
      
      // Apply gravity
      player.velocityY += GRAVITY;
      player.y += player.velocityY;
      
      // Rotate cube when in air
      if (!player.onGround) {
        player.rotation += player.rotationSpeed;
        if (player.rotation >= 360) player.rotation -= 360;
      } else {
        // Snap to 90 degree increments on ground
        player.rotation = Math.round(player.rotation / 90) * 90;
      }
      
      // Ground collision
      if (player.y + player.size >= GROUND_Y) {
        player.y = GROUND_Y - player.size;
        player.velocityY = 0;
        player.onGround = true;
      }
      
      // Ceiling collision
      if (player.y < 0) {
        player.y = 0;
        player.velocityY = 0;
      }
      
      // Check jump pad collision
      const playerCenterX = player.x + player.size / 2;
      const playerBottom = player.y + player.size;
      
      for (let pad of jumpPads) {
        const padX = pad.x - cameraX;
        const padY = GROUND_Y - 20;
        const padSize = 40;
        
        if (playerCenterX > padX && playerCenterX < padX + padSize &&
            playerBottom >= padY && playerBottom <= padY + 20 &&
            player.onGround && player.velocityY >= 0) {
          player.velocityY = -18; // Extra bounce
          player.onGround = false;
          break;
        }
      }
    }
    
    // Update camera
    function updateCamera() {
      if (gameState !== 'playing') return;
      
      // Camera follows player with slight offset
      const targetX = player.x - 200;
      cameraX += (targetX - cameraX) * 0.1;
      
      // Also move forward with game speed
      cameraX += GAME_SPEED;
      levelProgress = cameraX;
      
      // Check level complete
      if (levelProgress >= LEVEL_LENGTH) {
        completeLevel();
      }
    }
    
    // Check collisions
    function checkCollisions() {
      if (gameState !== 'playing') return;
      
      const playerLeft = player.x;
      const playerRight = player.x + player.size;
      const playerTop = player.y;
      const playerBottom = player.y + player.size;
      
      // Block collisions
      for (let block of blocks) {
        const blockX = block.x - cameraX;
        const blockY = GROUND_Y - block.height;
        
        if (playerRight > blockX && playerLeft < blockX + block.width &&
            playerBottom > blockY && playerTop < blockY + block.height) {
          gameOver();
          return;
        }
      }
      
      // Ground spike collisions
      for (let spike of groundSpikes) {
        const spikeX = spike.x - cameraX;
        const spikeY = GROUND_Y - 30;
        
        // Triangle collision - simplified
        const spikeCenterX = spikeX + spike.width / 2;
        const playerCenterX = player.x + player.size / 2;
        const distX = Math.abs(playerCenterX - spikeCenterX);
        const distY = playerBottom - spikeY;
        
        if (distX < spike.width / 2 + player.size / 2 && 
            distY > 0 && distY < 30 && 
            playerBottom > spikeY) {
          gameOver();
          return;
        }
      }
    }
    
    // Update score
    function updateScore() {
      if (gameState === 'playing') {
        score = Math.floor(levelProgress / 10);
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('gdBest', bestScore.toString());
        }
        updateUI();
      }
    }
    
    // Update UI
    function updateUI() {
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('bestDisplay').textContent = bestScore;
    }
    
    // Drawing functions
    function drawBackground() {
      // Dark gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#0a0a1a');
      gradient.addColorStop(0.5, '#050510');
      gradient.addColorStop(1, '#000000');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Subtle grid
      ctx.strokeStyle = 'rgba(0, 255, 65, 0.03)';
      ctx.lineWidth = 1;
      for (let i = 0; i < canvas.width; i += 50) {
        const x = i - (cameraX % 50);
        if (x >= 0 && x <= canvas.width) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
      }
    }
    
    function drawGround() {
      // Ground base
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, GROUND_Y, canvas.width, GROUND_HEIGHT);
      
      // Ground top line with glow
      ctx.strokeStyle = '#00ff41';
      ctx.lineWidth = 3;
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#00ff41';
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y);
      ctx.lineTo(canvas.width, GROUND_Y);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    function drawPlayer() {
      ctx.save();
      
      const centerX = player.x - cameraX + player.size / 2;
      const centerY = player.y + player.size / 2;
      
      ctx.translate(centerX, centerY);
      ctx.rotate((player.rotation * Math.PI) / 180);
      
      // Cube with glow
      ctx.shadowBlur = 20;
      ctx.shadowColor = player.color;
      ctx.fillStyle = player.color;
      ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);
      ctx.shadowBlur = 0;
      
      // Cube outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(-player.size / 2, -player.size / 2, player.size, player.size);
      
      // Cube face
      ctx.fillStyle = '#000000';
      const eyeSize = 4;
      const eyeY = -player.size / 2 + 8;
      ctx.fillRect(-player.size / 2 + 6, eyeY, eyeSize, eyeSize);
      ctx.fillRect(-player.size / 2 + player.size - 10, eyeY, eyeSize, eyeSize);
      ctx.fillRect(-player.size / 2 + 8, -player.size / 2 + player.size - 12, player.size - 16, 3);
      
      ctx.restore();
    }
    
    function drawBlocks() {
      ctx.fillStyle = '#ff0040';
      
      for (let block of blocks) {
        const x = block.x - cameraX;
        
        if (x > -block.width && x < canvas.width) {
          const y = GROUND_Y - block.height;
          
          // Block shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(x + 2, y + 2, block.width, block.height);
          
          // Block
          ctx.fillStyle = '#ff0040';
          ctx.fillRect(x, y, block.width, block.height);
          
          // Block outline
          ctx.strokeStyle = '#cc0033';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, block.width, block.height);
          
          // Block glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff0040';
          ctx.fillRect(x, y, block.width, 3);
          ctx.shadowBlur = 0;
        }
      }
    }
    
    function drawJumpPads() {
      for (let pad of jumpPads) {
        const x = pad.x - cameraX;
        const y = GROUND_Y - 20;
        const size = 40;
        
        if (x > -size && x < canvas.width) {
          // Jump pad glow
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#ffff00';
          
          // Yellow jump pad
          ctx.fillStyle = '#ffff00';
          ctx.fillRect(x, y, size, 20);
          
          // Outline
          ctx.strokeStyle = '#ffaa00';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, size, 20);
          
          // Arrows
          ctx.fillStyle = '#000000';
          ctx.shadowBlur = 0;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(x + 8 + i * 12, y + 15);
            ctx.lineTo(x + 12 + i * 12, y + 10);
            ctx.lineTo(x + 16 + i * 12, y + 15);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
    }
    
    function drawSpikes() {
      ctx.fillStyle = '#ff0040';
      
      for (let spike of groundSpikes) {
        const x = spike.x - cameraX;
        const width = spike.width;
        const height = 30;
        
        if (x > -width && x < canvas.width) {
          const y = GROUND_Y - height;
          
          ctx.beginPath();
          ctx.moveTo(x, y + height);
          ctx.lineTo(x + width / 2, y);
          ctx.lineTo(x + width, y + height);
          ctx.closePath();
          
          // Spike glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff0040';
          ctx.fill();
          ctx.shadowBlur = 0;
          
          // Spike outline
          ctx.strokeStyle = '#cc0033';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }
    
    function drawProgress() {
      if (gameState === 'playing') {
        const progress = Math.min(levelProgress / LEVEL_LENGTH, 1);
        
        // Progress bar background
        ctx.fillStyle = 'rgba(0, 255, 65, 0.2)';
        ctx.fillRect(0, canvas.height - 8, canvas.width, 8);
        
        // Progress bar
        ctx.fillStyle = '#00ff41';
        ctx.fillRect(0, canvas.height - 8, canvas.width * progress, 8);
        
        // Progress indicator
        ctx.fillStyle = '#00ff88';
        ctx.fillRect(canvas.width * progress - 3, canvas.height - 12, 6, 12);
      }
    }
    
    // Game state functions
    function startGame() {
      resetGame();
      gameState = 'playing';
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('completeScreen').classList.add('hidden');
      updateUI();
    }
    
    function restartGame() {
      resetGame();
      gameState = 'playing';
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('completeScreen').classList.add('hidden');
      updateUI();
    }
    
    function showStartScreen() {
      gameState = 'menu';
      document.getElementById('startScreen').classList.remove('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('completeScreen').classList.add('hidden');
    }
    
    function gameOver() {
      gameState = 'gameOver';
      document.getElementById('gameOverText').textContent = `Score: ${score}`;
      document.getElementById('gameOverScreen').classList.remove('hidden');
    }
    
    function completeLevel() {
      gameState = 'complete';
      document.getElementById('completeScreen').classList.remove('hidden');
    }
    
    // Event listeners
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        jump();
      }
    });
    
    canvas.addEventListener('click', jump);
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    });
    
    // Game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawBackground();
      
      if (gameState === 'playing') {
        updatePlayer();
        updateCamera();
        checkCollisions();
        updateScore();
      }
      
      drawGround();
      drawBlocks();
      drawJumpPads();
      drawSpikes();
      drawPlayer();
      drawProgress();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Initialize
    initPlayer();
    updateUI();
    gameLoop();
  </script>
</body>
</html>
